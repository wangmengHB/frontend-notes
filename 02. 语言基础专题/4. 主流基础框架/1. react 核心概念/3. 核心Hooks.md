
# useState



# React.useEffect

React.useEffect 是为了处理 side effect 而设计的，这里有一段 side effect 的定义。If the functional component makes calculations that don’t target the output value, then these calculations are named side-effects. 

在 React class 组件中，与 useEffect 对应的就是 class 组件的生命周期。

1. componentDidMount 
```js
useEffect(() => {
    // componentDidMount
}, [])
```

2. componentWillUnmount (cleanup)
```js
useEffect(() => {
    return function cleanup() {
        // componentWillUnmount
    }
}, [])
```
这里和 class 组件有一个明显的不同，RFC 组件在每一次执行 side effect 的时候，都先将上一次的 cleanup 先执行一次，最后一次 unmount 组件的时候，会执行最新的 cleanup. 


3. componentDidMount + componentDidUpdate(with equal check)
```js
useEffect(() => {
    // 1. componentDidMount
    // 2. componentDidUpdate  
    // if (prevProps.xxx !== this.props.xxx || prevProps.yyy !== this.props.yyy)
}, [xxx, yyy])

```
在以前的 class 组件中，经常会根据 props 的去 fetch 数据，并且当 props 发生变化时需要更新数据，所以重复的代码会在 componentDidMount 和 componentDidUpdate 中重复写两遍。 关于这一点在 React Hooks 中更简洁了。这是一个大的改进。 







# useCallback(fn, [dep])

React.useCallback 主要是用于解决的问题是，使回调函数在目标依赖参数不变的情况下，返回的是上一次 render 过程中的的函数实例，主要为了解决以下3个场景：
1. 避免 React.memo 包装组件的不必要的 render。（如果这是一个性能问题）
2. 该回调函数是其他 hooks 的依赖，例如，useEffect.   
3. 该回调函数是一个 debounced / throttled 函数，并且还有一些内部状态。  

When the function object is a dependency to other hooks, e.g. useEffect(..., [callback])
When the function has some internal state, e.g. when the function is debounced or throttled.

useCallback 通常是和 memo 配套出现的，单独使用没有什么意义。    









# Articles:
1. https://dmitripavlutin.com/react-useeffect-explanation/
2. https://dmitripavlutin.com/react-useeffect-infinite-loop/
3. https://dmitripavlutin.com/react-hooks-stale-closures/
4. https://reactjs.org/docs/hooks-rules.html
5. https://dmitripavlutin.com/dont-overuse-react-usecallback/