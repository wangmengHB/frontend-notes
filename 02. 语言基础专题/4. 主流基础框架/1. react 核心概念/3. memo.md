# React.memo(RFC, equalFunc?)

React.memo 的作用就是将一个函数组件（RFC）包装成具有 PureComponent 特性，只有当 Props 发生变更（浅比较）时， render 才会触发。
React.memo 的第二个参数是可选的，默认情况下是按照浅比较决定是否 render，如果传入 equalFunc, 可以自己定制比较行为。如果 prevProps 和 nextProps 一致，则 equalFunc 必须返回 true。
React.memo 只能作用于函数组件。

不要通过第二个参数 equalFunc 去主动忽略回调函数的变化，否则会陷入闭包陷阱。

Bad Example:
```js
const equalFunc = (prevProps, nextProps) => {
    if (
        prevProps.name === nextProps.name && 
        prevProps.isSelected === nextProps.isSelected &&
        prevProps.onSelect.toString() === nextProps.onSelect.toString()
    ) {
        return true;
    }

    return false; 
}

const ListItem = (props) => {
    const { name, isSelected, onSelect } = props;
    console.log(`list item (${name}) is rendered`);
    return (
        <li onClick={() => onSelect(name, !isSelected)}>
            { name }:{ isSelected? 'selected': ''}
        </li>
    )
}

const ListItemMemo = memo(ListItem, equalFunc);

const List = () => {
    // this is the mock data;
    const data = [1,2,3,4,5,6,7,8,9,10,11,12];

    const [selectedNames, setSelectedNames] = useState([]);
    
    return (
        <div>
            <div>
                <button onClick={() => setSelectedNames([...data])}>Select All</button>
                <button onClick={() => setSelectedNames([])}>UnSelect All</button>
            </div>
            <ul>
                {data.map((name) => {
                    return (
                        <ListItemMemo 
                            key={name}
                            name={name}
                            isSelected={selectedNames.indexOf(name) > -1}
                            onSelect={(name, isSelected) => {
                                const currentSelectedNames = selectedNames;
                                let index = currentSelectedNames.indexOf(name);
                                const nextNames = [...currentSelectedNames];
                                if (isSelected && index === -1) {
                                    nextNames.push(name);
                                } else {
                                    nextNames.splice(index, 1);
                                }
                                setSelectedNames(nextNames)
                            }}
                        />
                    )
                })}
            </ul>
        </div>
    )
}

```

# articles:
1. https://dmitripavlutin.com/use-react-memo-wisely/
2. https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab




