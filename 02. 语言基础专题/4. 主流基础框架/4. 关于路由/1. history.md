

# 路由必知必会 （一）

浏览器处理路的相关API




## 原生的 history 对象 
https://developer.mozilla.org/zh-CN/docs/Web/API/History
https://developer.mozilla.org/zh-CN/docs/Web/API/History_API/Working_with_the_History_API
https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event

history 对象是用于操作当前页面的浏览会话历史。
history 对象只有三个属性：
* length (只读), 
* state (只读), 
* scrollRestoration (可用值：'auto' | 'manual').

对于浏览器来说，它不仅会记录当前站点的历史，也会记录其他站点的历史。
出于最基本的安全考虑，history 对象是绝对不能操作用户的其他历史，所以当 back 或者 forward 行为超出当前站点边界时，一定会触发浏览器 reload 行为，进入到别的站点，又会是一个新的 history 对象。

所以，当页面 reload 时（并且没有 pushState/replaceState 行为）， history.state 一定是 null. 可以很容易理解，history 内部是一个栈的数据结构。


### pushState 和 replaceState
`pushState(state, title, [url, ])`
history.pushState 顾名思义，就是给当前的 history 栈中压入一条新记录，并且当前 history.state 指向的是这条新记录。
history.replaceState 则是用刚刚创建的 state 替换掉 history 栈里的当前记录。
重点需要注意的是：
1. history.state 指向的是刚刚创建的 state。
2. history.pushState() 和 history.replaceState() 并不会触发任何路由事件, 无论是否为 hash 路径。
3. 调用这两个方法的时候，可以不传 url, 仅仅只更新 state 和 title（虽然这种场景比较少见）。

小技巧：
当我们维护一个老旧系统时，经常会遇到需要更新 url 但是又不能触发系统的路由机制，这个时候可以使用：
`history.replaceState(history.state, document.title, nextUrl)`， 它不会影响原有的路由机制。

提示：任何一个页面的初始化过程都不应该依赖 history.state, 所有的关键信息应该在 url 上体现，否则系统后期将会无法维护。

### back, forward, go
这三个方法顾名思义，就是操作当前站点的浏览历史的，对于 go 方法来说，-1 表示之前的，1 就是下一个，如果超出范围了，不会发生任何作用。

注意：这三个方法对于 history.state 的影响都是异步的，只有在 popstate 事件实际触发的时候，history.state 才会发生变化。


## 路由相关的事件：
1. popstate
2. hashchange
3. beforeunload (可选)
重要的事情再强调一遍：pushState 和 replaceState 不会触发任何路由事件。

严格意义上讲，beforeunload 事件是和路由事件无关的，当浏览器窗口关闭或者刷新时，会触发beforeunload事件。
它的作用就是弹出一个浏览器原生的确认框提示用户是否离开页面。这个弹出框是不可定制的，并且它的事件 handler 的写法基本上是固定的，如果你需要这个行为的话。
```js
window.addEventListener('beforeunload', (event) => {
  // Cancel the event as stated by the standard.
  event.preventDefault();
  // Chrome requires returnValue to be set.
  event.returnValue = '';
});
```
之所以将 beforeunload 事件列到这里，是因为:
1. 直接操作 location 对象中的非 hash 属性（主要是 pathname 和 search）时，会触发浏览器的 reload.
2. 点击 a 标签（target=“_self”）的 href 地址为非 hash 路径时，会出发浏览器的 reload.
3. 还有一个不重要的原因是，在`react-router` 中依赖了一个叫 `history`的 library 中用到了它，但是 `vue-router` 中没有用到的。
总之，beforeunload 事件在路由事件中不是必需的，完全可以去掉。   


这里需要重点注意的是：
任何会触发浏览器 reload 行为，都会导致 popstate 和 hashchange 事件的 handler 可能被绕过去。


为了处理 `a` 标签的导航问题( 特别是非 hash 路由的情况)，所以在 react-router-dom 中提供了 Link 组件来解决这个问题。
Link 组件对 `a` 标签做了一层封装，拦截了 click 行为。 在 click 行为中, 它会去 pushState/replaceState 并且主动触发 Router 组件的 re-render。




















## location 对象







在页面路由问题中需要解决的几个核心的问题：
1. 子页面和公共布局部分 
2. SPA 和 MPA 混合
3. hash 路由和 H5 路由
4. 动态路由
5. 路由跳转的中间拦截能力
6. 微前端架构


























几个主要的开源项目：
1. history
2. react-router
3. vue-router











