
# Articles:

https://microsoft.github.io/monaco-editor/monarch.html




# 基本原理

通过`正则表达式`匹配字符串，将匹配的字符串在 render 时赋上一个 token 属性，这个 token 是和 DOM 里的 class 相对应的。


# Monarch JSON 的基本属性
* ignoreCase: optional, default false
* defaultToken: optional, default 'source', 可以设置为 'invalid'
当所有的规则都没有匹配上时，给字符串附上一个默认的 token.
* brackets: optional, 它是 tokenizer 用于匹配括号使用的。
default:
```js
[ 
    ['{','}','delimiter.curly'],
    ['[',']','delimiter.square'],
    ['(',')','delimiter.parenthesis'],
    ['<','>','delimiter.angle'] 
]
```
* tokenizer (核心)


# tokenizer
内置的 token 即 class 名称有如下：
```
identifier         entity           constructor
operators          tag              namespace
keyword            info-token       type
string             warn-token       predefined
string.escape      error-token      invalid
comment            debug-token
comment.doc        regexp
constant           attribute

delimiter .[curly,square,parenthesis,angle,array,bracket]
number    .[hex,octal,binary,float]
variable  .[name,value]
meta      .[content]
```

tokenizer 是一个定义 states 的对象，第一个 state 是初始 state。
当 tokenizer 处于某一个 state 中时，只有这个 state 中的 rule 会被执行。所有的 rule 都是按照顺序匹配。
当匹配命中时，它的 action 会决定匹配项的 token class，不会再执行其他的 rule。
所以，高效地组织 rule 的顺序很重要，例如，把 whitespace 和 identifiers 放前面。

使用符号 . 分隔 sub-state。当 tokenizer 寻找一个 state 里的 rules 时，它会首先尝试完整的 state name，然后再查找它的 parent，一直到找到定义。
例如，"comment.block" 和 "comment.foo" 都会按照 comment 的 rules 处理。
使用层级结构的 state names 来维护一个复杂的词法 states，特别是复杂嵌套结构。
```js
{
    tokenizer: {
        root: [

        ],
    }
}
```


## rules
每个 state 是由很多 rule 构成的数组，每个 rule 的基本形式如下：
* [regex, action] 
* [regex, action, next]
* { include: state }





